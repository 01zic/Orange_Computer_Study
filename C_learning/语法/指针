指针的作用：
1.传入较大数据时用作参数，比如数组
2.传入数组后对数组进行操作（数组和指针可以一起使用）
3.当函数返回值不止一个的时候，可以用指针作为参数让它带出结果（你希望返回多个结果值的时候可以在参数列表多设置几个指针，通过指针来对变量进行操作以获得你期望的值）
4.当函数修改不止一个变量的时候（同上，交换，输出等等）
5.动态申请内存的时候：int *a=(int *)malloc(sizeof(int)*n)，运行的时候确定数组的大小，即可通过指针实现动态大小的数组

指针的知识点：
1.指针是指向变量地址的变量，它也有地址
2.使用&运算符来给指针类型变量赋值：*p=&i
3.使用*运算符来取得指针指向的地址所储存的变量 int i=5;int *p=&i;printf("%d%,*p);这里输出是5
4.对指针进行加减运算的时候，指向的是指针前一个或后一个元素的地址（存储单元），指针的值（就是指针指向的变量的地址）的改变取决于指针所指向的变量的类型，例如int类型是四个字节，char类型是一个字节
5.数组名就是数组的首地址，可以将数组名直接复制给指针，代表指针指向数组的首地址，对指针进行加减操作就是对数组地址进行操作，可以通过*取得数组对应地址上的值，a[n]=*(a+n)
6.在函数原型和函数定义中可以用int a[]代替int *a,在函数原型中int a[],int *a,int [],int *这四种形式都是表示数组，在函数定义中只能使用int a[]和int *a
7.%p可以打印指针变量的值，打印出来的是指针指向变量的地址，地址是十六进制
8.不能解引用未初始化的指针
9.void *一个没有初始化指针的类型的指针
10.两个不同类型的指针不能相互赋值

指针变量的基本操作
1.赋值：可以把地址赋值给指针。例如：数组名，带地址符号&的变量名，另一个已经赋值的指针
2.解引用：*运算符给出指针指向地址上储存的值
3.取地址：指针本身也有自己的地址和值，指针的值就是指针所指向变量的地址
4.指针与整数相加减：可以使用+和-运算符把指针和整数相加减，无论什么情况，整数都会和指针所指向的变量的类型大小相乘，然后把初始结果与指针的初始地址相加减，简单来说就是指针的变化与数组的下标变化一致
5.指针相减运算：求差的两个指针要指向同一个数组的不同元素，差值的大小就是这两个数组元素在数组中的距离大小，差值的单位是数组元素类型的单位

const关键字：
1.如果编写的函数需要修改传入数组的值，在声明数组形参的时候可以不使用const，这个时候在函数内对数组进行操作就是对通过数组元素的地址对数组元素进行操作，类似于地址传递
2.如果编写的函数不用修改传入的数组的值的时候，在声明数组形参的时候需要使用const，这个时候在函数内数组元素就是常量，可以在函数内部进行值传递
3.在*前面加const代表不能通过这个指针去改变指针所指向变量的值，在*后面加const代表指针不能指向其他变量的地址，只能指向初始化变量的地址
4.把const数据或者非const数据的地址初始化为指向const的指针或为其赋值是合法的
5.非const数据的地址只能赋值给普通指针
6.可以使用两次const，这样指针既不能修改它所指向的地址，也不能修改它所指向地址上的值
7.把const指针交给非const指针不安全，因为这样可以通过使用新的指针去改变const指针指向的数据

const和define的区别：
1.define是预编译指令，而const是普通变量的定义。define定义的宏是在预处理阶段展开的，而const定义的只读变量是在编译运行阶段使用的。
2.const定义的是变量，而define定义的是常量。define定义的宏在编译后就不存在了，它不占用内存，因为它不是变量，系统只会给变量分配内存。
但const定义的常变量本质上仍然是一个变量，具有变量的基本属性，有类型、占用存储单元。可以说，常变量是有名字的不变量，而常量是没有名字的。
有名字就便于在程序中被引用，所以从使用的角度看，除了不能作为数组的长度，用const定义的常变量具有宏的优点，而且使用更方便。所以编程时在使用const和define都可以的情况下尽量使用常变量来取代宏。
3.const定义的是变量，而宏定义的是常量，所以const定义的对象有数据类型，而宏定义的对象没有数据类型。所以编译器可以对前者进行类型安全检查，
而对后者只是机械地进行字符替换，没有类型安全检查。这样就很容易出问题，即“边际问题”或者说是“括号问题”。
